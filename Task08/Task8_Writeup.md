
# **Task 8**

## <ins>Topics:</ins>

Cryptanalysis

## <ins>Task Description<ins>

Knowing the contents we'd send to initialize a new session is good progress. The next step is to uncover additional details about the protocol.

We suspect the Docker malware was specifically tailored to PANIC's image and written exclusively to steal their source code. Given that, it seems likely that the malware only contains a subset of the communications protocol supported by the LP. Our network capture does appear to have communications from other malware variants. If we could decrypt those communications, then we could analyze the underlying plaintext to recover additional details about the protocol.

As a reminder, our analysts believe the protocol includes an initial crypt negotiation followed by a series of client-generated requests, which the LP responds to.

Decrypt the other sessions captured in the PCAP. Provide the UUIDs of each of the clients associated with the DIB that registered with the LP.

## <ins>Provided Files<ins>

None

## <ins>Solution<ins>

### **1) Static anlysis of make binary**

Looking through the decompiled code in Ghidra, we see that the communication procedure used by the malware is contained in the function `umopisfsyvqgq` as follows:

<ol>
<li>The malware generates a UUID and then collects the username, operating system, malware version, and current Unix time.</li>
<li>A fingerprint is generated by base64 encoding the username, operating system, malware version, and Unix time and then concatenating these with a comma delimiter as follows: <code>username=username,version=version,os=os,timestamp=timestamp</code>.
<li>A session key is generated by concatenating the username in lowercase, the first seven characters of the version number (X.X.X.X), and the Unix timestamp with a + delimiter as follows: <code>username+version+timestamp</code>. This session key is then hashed using SHA256.</li>
<li>A public and private key are generated for the malware. A nonce is also generated and the listening post public key is collected. A <code>libsodium</code> public box is then given the malware private key and the listening post public key. The fingerprint generated earlier is encrypted with this public box and the nonce. Finally, the malware sends a message to the listening post that contains the malware public key, a length header, the nonce, and the encrypted fingerprint concatenated together. This message is the initial crypt negotiation and provides the listening post with all information needed to generate the session key.</li>
<li>The malware generates a vector of messages to later encrypt and send to the listening post. The first message is the initialization message addressed in Task 7. This message is followed by a set of upload messages, which send files containing information about the git repo inside the PANIC image. Finally, an end message is added to the vector</li>
<li>Each message in the vector is encrypted using a <code>libsodium</code> secret box. The secret box uses the SHA256 hashed session key as the key and a randomly generated nonce. For each message, a length header, nonce, and ciphered message are concatenated and added to the ciphered messages vector.</li>
<li>Each ciphered message is sent to the listening post and the malware recieves encrypted responses back. The encrypted responses are decrypted using a <code>libsodium</code> secret box using the SHA256 hashed session key and checked for a proper response code before moving to the next ciphered message.</li>
</ol>

As we can see, the bulk of messages are encrypted using the `libsodium` secret box with a SHA256 hashed session key. The session key only contains three varying properties: username, malware version, and timestamp.

So, in order to decrypt the messages in `capture.pcap`, we generate a session key guess and see if it properly decrypts the message.

### **2) Extract initialization messages from capture.pcap**

First, we use Wireshark to export the initialization message packets from `capture.pcap`. We can see by looking through the packets that each session starts with a 32 byte packet (the malware public key), a 131-139 byte packet (the encrytped fingerprint), and a 78 byte packet (the initialization message). We filter using the query `ip.dst == 10.78.211.175 and tcp.payload and tcp.payload and tcp.len == 78` and use `Ctrl+Click` to select the first 78 byte packet for each source ip, then use `File > Export Packet Dissections > As JSON...` to sace the packets in `initialization_packets.json`.

We then run our script `process_packet_data.py` to extract the information we need from `initialization_packets.json` and filter out packets that did not come from a DIB IP address and write the output to `encrypted_messages.txt`.

### **3) Brute force decryption of initialization messages**

Now we can brute force decrypt the initialization messages we extracted.

For the version, we use every possible shortened version number matching the format X.X.X.X, where X is an integer between 0-9 inclusive.

For the timestamp, we use the timestamp of the message we are trying to decrypt from `capture.pcap` and check timestamps +/- 10 seconds from this value.

For the username, we used `names.txt` from [SecLists](https://github.com/danielmiessler/SecLists) (found in Usernames/Names).

We run our brute forcing script and get the following UUIDs from the decrypted messages:

fb3ef669-eada-4b6a-ac6f-5e845927aaf1

9839e676-6282-4a9b-8c01-751caff2b591

d8d9773f-1b1b-45b1-86c4-a50587a8327e
